#! /usr/bin/ksh

# Original Author: Tim Mooney (mooney@plains.nodak.edu)
# $Id: irix6.prov,v 1.3 1999/01/22 00:25:26 jbj Exp $
#
# This file is distributed under the terms of the GNU Public License
#
# find-provides is part of RPM, the Red Hat Package Manager.  find-provides
# reads a list of full pathnames (in a package) on stdin, and outputs all
# shared libraries provided by (contained in) the package.
#
# NOTE: I use `:' as the delimiter (by default) between the library soname
# and any library version info.  This is because IRIX libraries (even
# system libraries) have "version information" in both the soname and the
# internal version field, so it's important to be able to separate those
# fields.  If we just used `.', we wouldn't know where the soname ends and
# the version infromation begins.
#
#
# On IRIX, use `elfdump -L' to find what libraries a package provides
#
# Example `elfdump -L' output:
#
#$elfdump -L /usr/lib/libc.so
#
#
#/usr/lib/libc.so:
#
#  **** DYNAMIC SECTION INFORMATION ****
#.dynamic :
#[INDEX]	Tag	 Value
#[0]	HASH     0xfa099d0
#[1]	STRTAB   0xfa0027c
#[2]	SYMTAB   0xfa10e3c
#[3]	STRSZ    0x9751
#[4]	SYMENT   0x10
#[5]	INIT     0
#[6]	FINI     0
#[7]	RLDVERS  0x1
#[8]	FLAGS    0x1411
#[9]	BASEADDR 0xfa00000
#[10]	LOCGOTNO 0x3c
#[11]	PROTECT  0x3c
#[12]	HIDDEN   0x12
#[13]	CNFLCTNO 0
#[14]	LBLISTNO 0
#[15]	SYMTABNO 0xd19
#[16]	UNREFEXT 0x8
#[17]	GOTSYM   0x8b3
#[18]	LOCAL    0x12
#[19]	LOCALPG  0x1
#[20]	LOCALPG  0x10
#[21]	PLTGOT   0xfb483b0
#[22]	RLDTXT_ADR0xfb6b580
#[23]	OPTIONS  0xfa000f4
#[24]	SONAME   libc.so.1
#[25]	TIMSTAMP Jun 16 18:23:15 1997	
#[26]	CHECKSUM 0x92321a0c
#[27]	IVERSION sgi1.0
#[28]	REL      0xfa1dfcc
#[29]	RELSZ    0x1988
#[30]	RELENT   0x8
#[31]	MSYM     0xfa1f954
#[32]	COMPCTSIZE0xc60c
#No Library List Section in /usr/lib/libc.so
#

PATH=/usr/bin:/usr/sbin
export PATH

for f in `cat - | xargs /usr/bin/file | egrep 'ELF.*dynamic lib' | cut -d: -f1`
do
	elfdump -L $f 2>/dev/null | awk '

		BEGIN { 
			FS = " ";
			RS = "\n";
			OFS = "";

			# The character that should separate the soname from
			# the version information.  If you change this, you
			# should also change the same variable in the IRIX
			# find-requires script
			soname_version_delimiter=":"

			found_soname = 0;
			found_iversion = 0;
		}

		# Uncomment the next line for some debugging info.
		#{ print NR , ":", $0  }

		/[	 ]+SONAME .*[ 	]*$/ {
			found_soname = 1;
			numfields = split($0, internal_name)
			if (numfields == 3) {
				soname = $3
			} else {
				#
				# Should never be here.
				#
				print "Really odd looking soname:", $0 | "cat 1>&2"
				exit
			}
		}

		/[ 	]+IVERSION .*[ 	]*$/ {
			if (found_soname == 1) {
				numfields = split($0, iversion)
				if (numfields == 3) {
					version = $3
					#
					# handle libraries with multiple versions, like
					# 1.1:1.2.  Since they really provide both versions,
					# we need to generate output for each version.
					#
					numfields = split(version, versions, ":")
					if (numfields > 1) {
						for (i = 1; i < numfields; i++) {
							print soname, soname_version_delimiter, versions[i]
						}
						#
						# let our END routine print out the *last* version
						# provided
						#
						version = versions[numfields]
					}
					#
					# stick a fork in us.
					#
					found_iversion = 1;
					exit
				} else {
					#
					# handle libraries with comments and other junk in
					# the version field.  IRIX has a number of system libraries
					# with whitespace and other junk in the version field!
					#
					# we discard the whitespace and keep the identifier after
					# the # sign.
					#
					version = iversion[numfields]
					numfields = split(version, version_junk, "#")
					if (numfields > 1) {
						version = version_junk[numfields]
						found_iversion = 1;
					}
				}
			} else {
				#
				# found an iversion without an soname.  Is that possible?
				#
				print "Found version but no soname:", $0 | "cat 1>&2"
				exit
			}
		}

		#
		# we could probably watch for some other token (like RELSZ)
		# that *generally* occurs later in the input than the stuff we watch
		# for, and exit if we see it, but it is just as easy to read all
		# the output, even after we have seen what we are looking for.
		#

		END {
			# Uncomment the next line for debugging info
			#{ print "END: NR: ", NR }
			if ( (found_soname == 1) && (found_iversion == 1) ) {
				print soname, soname_version_delimiter, version
				exit
			} else if (found_soname == 1) {
				#
				# no library version information
				#
				print soname
			}
			# else do nothing
		}
	' # end of awk
#done | sort -u
#comment out the previous line and uncomment the next line when debugging
done
